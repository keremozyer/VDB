using Dasync.Collections;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using VDB.Architecture.AppException.Model.Derived.DataNotFound;
using VDB.Architecture.Concern.ExtensionMethods;
using VDB.Architecture.Concern.Helper;
using VDB.MicroServices.VulnerabilityDetector.Concern.Constants;
using VDB.MicroServices.VulnerabilityDetector.Concern.Options;
using VDB.MicroServices.VulnerabilityDetector.DB.UnitOfWork;
using VDB.MicroServices.VulnerabilityDetector.ExternalData.Manager.Contract;
using VDB.MicroServices.VulnerabilityDetector.ExternalData.Model.Notification;
using VDB.MicroServices.VulnerabilityDetector.Manager.Business.Interface;
using VDB.MicroServices.VulnerabilityDetector.Manager.Operation.Interface;
using VDB.MicroServices.VulnerabilityDetector.Model.DTO._CVEData;
using VDB.MicroServices.VulnerabilityDetector.Model.DTO.ProductCatalog;
using VDB.MicroServices.VulnerabilityDetector.Model.Entity;

namespace VDB.MicroServices.VulnerabilityDetector.Manager.Business.Implementation
{
    public class ReportBusinessManager : IReportBusinessManager
    {
        private readonly IVulnerabilityDetectorUnitOfWork DB;
        private readonly ReportSettings ReportSettings;
        private readonly IProductCatalogServiceManager ProductCatalogServiceManager;
        private readonly ICVEDataServiceManager CVEDataServiceManager;
        private readonly IReportDocumentBusinessManager ReportDocumentBusinessManager;
        private readonly IVulnerabilityReportOperations VulnerabilityReportOperations;
        private readonly INotificationServiceManager NotificationServiceManager;

        public ReportBusinessManager(IVulnerabilityDetectorUnitOfWork db, IOptions<ReportSettings> reportSettings, IProductCatalogServiceManager productCatalogServiceManager, ICVEDataServiceManager cveDataServiceManager, IReportDocumentBusinessManager reportDocumentBusinessManager, IVulnerabilityReportOperations vulnerabilityReportOperations, INotificationServiceManager notificationServiceManager)
        {
            this.DB = db;
            this.ReportSettings = reportSettings.Value;
            this.ProductCatalogServiceManager = productCatalogServiceManager;
            this.CVEDataServiceManager = cveDataServiceManager;
            this.ReportDocumentBusinessManager = reportDocumentBusinessManager;
            this.VulnerabilityReportOperations = vulnerabilityReportOperations;
            this.NotificationServiceManager = notificationServiceManager;
        }

        public async Task CreateReport(Guid id)
        {
            VulnerabilityReport vulnerabilityReport = await this.VulnerabilityReportOperations.GetAsync(id);
            if (vulnerabilityReport == null) throw new DataNotFoundException(entityName: typeof(VulnerabilityReport).GetDisplayName(), value: id);

            try
            {
                await ProcessReport(vulnerabilityReport);
            }
            catch (Exception exception)
            {
                await LogException(vulnerabilityReport, exception);
                throw;
            }            
        }

        private async Task LogException(VulnerabilityReport vulnerabilityReport, Exception exception)
        {
            vulnerabilityReport.ReportStatus = VulnerabilityReportConstants.ReportStatusError;
            vulnerabilityReport.ErrorMessage = exception.Message;
            vulnerabilityReport.ErrorDetail = exception.SerializeAsJson();
            await this.DB.SaveAsync();
        }

        private async Task ProcessReport(VulnerabilityReport vulnerabilityReport)
        {
            vulnerabilityReport.ReportCreationDate = DateTime.UtcNow;
            vulnerabilityReport.ReportStatus = VulnerabilityReportConstants.ReportStatusProcessing;
            this.VulnerabilityReportOperations.Update(vulnerabilityReport);
            await this.DB.SaveAsync();

            Catalog productCatalog = await this.ProductCatalogServiceManager.GetCatalog();
            if ((productCatalog?.Products.IsNullOrEmpty()).GetValueOrDefault()) return;

            foreach (ProductData product in productCatalog.Products)
            {
                product.ProductVersions = product.ProductVersions?.Where(v => v.Servers.HasElements());
            }

            await productCatalog.Products.Where(p => p.ProductVersions.HasElements())?.ParallelForEachAsync(async product =>
            {
                await GetProductsCVEData(product);
                ProcessProductsCVEData(productCatalog, product);
            });

            foreach (ProductData product in productCatalog.Products)
            {
                product.ProductVersions = product.ProductVersions?.Where(pv => pv.MatchedCVEs.HasElements());
            }
            productCatalog.Products = productCatalog.Products?.Where(p => p.ProductVersions.HasElements());

            if (productCatalog.Products.HasElements())
            {
                vulnerabilityReport.Base64ReportData = this.ReportDocumentBusinessManager.GenerateDocument(productCatalog, vulnerabilityReport);
                if (!String.IsNullOrWhiteSpace(vulnerabilityReport.Base64ReportData))
                {
                    SendReportNotification(vulnerabilityReport);
                }
            }
            
            vulnerabilityReport.ReportStatus = VulnerabilityReportConstants.ReportStatusCompleted;
            this.VulnerabilityReportOperations.Update(vulnerabilityReport);
            await this.DB.SaveAsync();
        }

        private void SendReportNotification(VulnerabilityReport vulnerabilityReport)
        {
            SendNotificationRequestModel request = new()
            {
                NotificationContext = this.ReportSettings.ReportNotificationSettings.NotificationContext,
                Content = this.ReportSettings.ReportNotificationSettings.Content,
                Subject = this.ReportSettings.ReportNotificationSettings.Subject,
                Attachments = new NotificationAttachmentModel[] { new ()
                {
                    Base64Data = vulnerabilityReport.Base64ReportData,
                    ContentType = this.ReportSettings.ReportNotificationSettings.ReportDocumentSettings.ContentType,
                    FileName = $"{vulnerabilityReport.CreatedAt.ToString(this.ReportSettings.ReportNotificationSettings.ReportDocumentSettings.ReportFileNameDateFormat)}.{this.ReportSettings.ReportNotificationSettings.ReportDocumentSettings.Extension}"
                } }
            };

            this.NotificationServiceManager.SendNotification(request);
        }

        private async Task GetProductsCVEData(ProductData product)
        {
            if (product == null) return;

            await product.ProductVersions?.ParallelForEachAsync(async version =>
            {
                await GetVersionsCVEData(product, version);
            });
        }

        private async Task GetVersionsCVEData(ProductData product, ProductVersionData version)
        {
            if (version == null) return;

            version.MatchedCVEs = (await this.CVEDataServiceManager.SearchByProductVersion(product.Vendor.Name, product.Name, version.Version))?.CVEs;
        }

        private void ProcessProductsCVEData(Catalog productCatalog, ProductData product)
        {
            List<ProductVersionData> versions = product.ProductVersions?.Where(pv => pv.MatchedCVEs.HasElements())?.ToList();
            if (versions.HasElements())
            {
                Parallel.ForEach(versions, version =>
                {
                    List<CVEData> directMatches = version.MatchedCVEs.Where(c => c.AdditionalRequiredProducts.IsNullOrEmpty())?.ToList();
                    ConcurrentBag<CVEData> matchedCVEs = directMatches == null ? new() : new(directMatches);
                    List<CVEData> cvesWithAdditionalProduct = version.MatchedCVEs?.Except(directMatches)?.ToList();
                    if (cvesWithAdditionalProduct.HasElements())
                    {
                        Parallel.ForEach(cvesWithAdditionalProduct, cveWithAdditionalProduct =>
                        {
                            ProcessCVERequiringAdditionalProduct(productCatalog, matchedCVEs, cveWithAdditionalProduct);
                        });
                    }
                    version.MatchedCVEs = matchedCVEs?.ToList();
                });
            }
        }

        private void ProcessCVERequiringAdditionalProduct(Catalog productCatalog, ConcurrentBag<CVEData> matchedCVEs, CVEData cveWithAdditionalProduct)
        {
            if (cveWithAdditionalProduct.AdditionalRequiredProducts.HasElements())
            {
                CancellationTokenSource cancellationTokenSource = new();
                ParallelOptions parallelOptions = new() { CancellationToken = cancellationTokenSource.Token };
                Parallel.ForEach(cveWithAdditionalProduct.AdditionalRequiredProducts, parallelOptions, additionalProductInCVE =>
                {
                    ConcurrentBag<bool> productFoundResults = new();

                    ProductData additionalProduct = productCatalog?.Products?.FirstOrDefault(p => p.Name == additionalProductInCVE.ProductName && p.Vendor?.Name == additionalProductInCVE.VendorName && p.ProductVersions.HasElements());
                    if ((additionalProduct?.ProductVersions.HasElements()).GetValueOrDefault())
                    {
                        Parallel.ForEach(additionalProduct.ProductVersions, parallelOptions, additionalProductVersion =>
                        {
                            productFoundResults.Add(ProcessAdditionalProductVersion(matchedCVEs, cveWithAdditionalProduct, additionalProductInCVE, additionalProductVersion));
                        });
                    }

                    if (productFoundResults.Any(r => r == true))
                    {
                        cancellationTokenSource.Cancel();
                    }
                });
            }
        }

        private bool ProcessAdditionalProductVersion(ConcurrentBag<CVEData> matchedCVEs, CVEData cveWithAdditionalProduct, CVEProductData additionalProductInCVE, ProductVersionData additionalProductVersion)
        {
            CVEMatchType? matchType = null;
            if (additionalProductInCVE.SpecificVersion == additionalProductVersion.Version)
            {
                matchType = CVEMatchType.SpecificVersion;
            }
            else if ((this.ReportSettings.AllVersionsIndicators?.Contains(additionalProductInCVE.SpecificVersion)).GetValueOrDefault())
            {
                matchType = CVEMatchType.WithoutVersion;
            }
            else if ((String.IsNullOrWhiteSpace(additionalProductInCVE.VersionRangeStart) || !additionalProductInCVE.VersionRangeStart.IsAllDigit(this.ReportSettings.StandartVersionSeperator)) &&
                     (String.IsNullOrWhiteSpace(additionalProductInCVE.VersionRangeEnd) || !additionalProductInCVE.VersionRangeEnd.IsAllDigit(this.ReportSettings.StandartVersionSeperator)))
            {
                matchType = CVEMatchType.NonNumericVersionRange;
            }
            else if (VersionHelpers.DoesVersionMatchRange(additionalProductVersion.Version, additionalProductInCVE.VersionRangeStart, additionalProductInCVE.VersionRangeEnd, additionalProductInCVE.IsStartingVersionInclusive, additionalProductInCVE.IsEndingVersionInclusive, this.ReportSettings.StandartVersionSeperator, this.ReportSettings.StandartVersionNumber))
            {
                matchType = CVEMatchType.NumericVersionRange;
            }
            else if ((this.ReportSettings.AllVersionsIndicators?.Contains(additionalProductVersion.Version)).GetValueOrDefault())
            {
                matchType = CVEMatchType.ProductWithoutVersion;
            }

            if (matchType != null)
            {
                CVEData matchedCVEData = cveWithAdditionalProduct.DeepCopy();
                matchedCVEData.MatchType = matchType;

                matchedCVEs.Add(cveWithAdditionalProduct);
                return true;
            }

            return false;
        }
    }
}
