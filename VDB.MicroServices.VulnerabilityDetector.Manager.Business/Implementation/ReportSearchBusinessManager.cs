using AutoMapper;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;
using VDB.Architecture.AppException.Model.Derived.Business;
using VDB.Architecture.AppException.Model.Derived.DataNotFound;
using VDB.Architecture.Concern.ExtensionMethods;
using VDB.Architecture.Concern.Helper.PredicateBuilding;
using VDB.Architecture.Concern.Resources.ResourceKeys;
using VDB.MicroServices.VulnerabilityDetector.Concern.Options;
using VDB.MicroServices.VulnerabilityDetector.Manager.Business.Interface;
using VDB.MicroServices.VulnerabilityDetector.Manager.Operation.Interface;
using VDB.MicroServices.VulnerabilityDetector.Model.DTO.File;
using VDB.MicroServices.VulnerabilityDetector.Model.Entity;
using VDB.MicroServices.VulnerabilityDetector.Model.Exchange.Report.SearchReports;

namespace VDB.MicroServices.VulnerabilityDetector.Manager.Business.Implementation
{
    public class ReportSearchBusinessManager : IReportSearchBusinessManager
    {
        private readonly IMapper Mapper;
        private readonly IVulnerabilityReportOperations VulnerabilityReportOperations;
        private readonly ReportDocumentSettings ReportDocumentSettings;

        public ReportSearchBusinessManager(IMapper mapper, IVulnerabilityReportOperations vulnerabilityReportOperations, IOptions<ReportDocumentSettings> reportDocumentSettings)
        {
            this.Mapper = mapper;
            this.VulnerabilityReportOperations = vulnerabilityReportOperations;
            this.ReportDocumentSettings = reportDocumentSettings.Value;
        }

        public async Task<SearchReportsResponseModel> Search(SearchReportsRequestModel request)
        {
            List<ExpressionModel> searchExpressions = new();
            if (request.Statuses.HasElements()) searchExpressions.Add(new ExpressionModel(nameof(VulnerabilityReport.ReportStatus), ExpressionOperators.InMethod, request.Statuses.ToList()));
            if (request.StartingDate != null) searchExpressions.Add(new ExpressionModel(nameof(VulnerabilityReport.ReportCreationDate), ExpressionOperators.GreaterThanOrEqual, request.StartingDate.Value.ToUniversalTime()));
            if (request.EndingDate != null) searchExpressions.Add(new ExpressionModel(nameof(VulnerabilityReport.ReportCreationDate), ExpressionOperators.LessThanOrEqual, request.EndingDate.Value.ToUniversalTime()));

            Expression<Func<VulnerabilityReport, bool>> searchExpression = PredicateBuilder.MakePredicate<VulnerabilityReport>(searchExpressions);

            List<VulnerabilityReport> reports = await this.VulnerabilityReportOperations.Search(searchExpression, request.PageIndex, request.PageSize);

            SearchReportsResponseModel response = new() { Reports = reports?.Select(report => this.Mapper.Map<VulnerabilityReportData>(report))?.ToList() };

            if (request.PageIndex > 0 && request.PageSize > 0 && response.Reports.HasElements())
            {
                response.TotalItemCount = await this.VulnerabilityReportOperations.GetCount(searchExpression);
            }

            return response;
        }

        public async Task<AppFile> GetReportBytes(Guid reportID)
        {
            VulnerabilityReport report = await this.VulnerabilityReportOperations.GetAsync(reportID);
            if (report == null) throw new DataNotFoundException(entityName: typeof(VulnerabilityReport).GetDisplayName(), value: reportID);
            if (String.IsNullOrWhiteSpace(report.Base64ReportData)) throw new BusinessException(ErrorResourceKeys.ReportDocumentDataNotExists);

            return new AppFile()
            {
                Data = Convert.FromBase64String(report.Base64ReportData),
                ContentType = this.ReportDocumentSettings.ContentType,
                FileName = $"{report.ReportCreationDate.Value.ToString(this.ReportDocumentSettings.ReportFileNameDateFormat)}.{this.ReportDocumentSettings.Extension}"
            };
        }
    }
}
