using Dasync.Collections;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using VDB.Architecture.Concern.ExtensionMethods;
using VDB.Architecture.Concern.Helper;
using VDB.MicroServices.VulnerabilityDetector.Concern.Options;
using VDB.MicroServices.VulnerabilityDetector.ExternalData.Manager.Contract;
using VDB.MicroServices.VulnerabilityDetector.Manager.Business.Interface;
using VDB.MicroServices.VulnerabilityDetector.Model.DTO._CVEData;
using VDB.MicroServices.VulnerabilityDetector.Model.DTO.ProductCatalog;

namespace VDB.MicroServices.VulnerabilityDetector.Manager.Business.Implementation
{
    public class ProductCatalogBusinessManager : IProductCatalogBusinessManager
    {
        private readonly IProductCatalogServiceManager ProductCatalogServiceManager;
        private readonly ICVEDataServiceManager CVEDataServiceManager;
        private readonly ReportSettings ReportSettings;

        public ProductCatalogBusinessManager(IOptions<ReportSettings> reportSettings, IProductCatalogServiceManager productCatalogServiceManager, ICVEDataServiceManager cveDataServiceManager)
        {
            this.ReportSettings = reportSettings.Value;
            this.ProductCatalogServiceManager = productCatalogServiceManager;
            this.CVEDataServiceManager = cveDataServiceManager;
        }

        public async Task<Catalog> GetCatalog()
        {
            Catalog productCatalog = await this.ProductCatalogServiceManager.GetCatalog();
            if ((productCatalog?.Products.IsNullOrEmpty()).GetValueOrDefault()) return null;

            foreach (ProductData product in productCatalog.Products)
            {
                product.ProductVersions = product.ProductVersions?.Where(v => v.Servers.HasElements());
            }

            await productCatalog.Products.ParallelForEachAsync(async product =>
            {
                await GetProductsCVEData(product);
                ProcessProductsCVEData(productCatalog, product);
            });

            foreach (ProductData product in productCatalog.Products)
            {
                product.ProductVersions = product.ProductVersions?.Where(pv => pv.MatchedCVEs.HasElements() && pv.Servers.HasElements());
            }
            productCatalog.Products = productCatalog.Products?.Where(p => p.ProductVersions.HasElements());

            return productCatalog;
        }

        private async Task GetProductsCVEData(ProductData product)
        {
            if (product == null) return;

            await product.ProductVersions?.ParallelForEachAsync(async version =>
            {
                await GetVersionsCVEData(product, version);
            });
        }

        private async Task GetVersionsCVEData(ProductData product, ProductVersionData version)
        {
            if (version == null) return;

            version.MatchedCVEs = (await this.CVEDataServiceManager.SearchByProductVersion(product.Vendor.Name, product.Name, version.Version))?.CVEs;
        }

        private void ProcessProductsCVEData(Catalog productCatalog, ProductData product)
        {
            List<ProductVersionData> versions = product.ProductVersions?.Where(pv => pv.MatchedCVEs.HasElements())?.ToList();
            if (versions.HasElements())
            {
                Parallel.ForEach(versions, version =>
                {
                    List<CVEData> directMatches = version.MatchedCVEs.Where(c => c.AdditionalRequiredProducts.IsNullOrEmpty())?.ToList();
                    ConcurrentBag<CVEData> matchedCVEs = directMatches == null ? new() : new(directMatches);
                    List<CVEData> cvesWithAdditionalProduct = version.MatchedCVEs?.Except(directMatches)?.ToList();
                    if (cvesWithAdditionalProduct.HasElements())
                    {
                        Parallel.ForEach(cvesWithAdditionalProduct, cveWithAdditionalProduct =>
                        {
                            ProcessCVERequiringAdditionalProduct(productCatalog, matchedCVEs, cveWithAdditionalProduct);
                        });
                    }
                    version.MatchedCVEs = matchedCVEs?.ToList();
                });
            }
        }

        private void ProcessCVERequiringAdditionalProduct(Catalog productCatalog, ConcurrentBag<CVEData> matchedCVEs, CVEData cveWithAdditionalProduct)
        {
            if (cveWithAdditionalProduct.AdditionalRequiredProducts.HasElements())
            {
                CancellationTokenSource cancellationTokenSource = new();
                ParallelOptions parallelOptions = new() { CancellationToken = cancellationTokenSource.Token };
                Parallel.ForEach(cveWithAdditionalProduct.AdditionalRequiredProducts, parallelOptions, additionalProductInCVE =>
                {
                    ConcurrentBag<bool> productFoundResults = new();

                    ProductData additionalProduct = productCatalog?.Products?.FirstOrDefault(p => p.Name == additionalProductInCVE.ProductName && p.Vendor?.Name == additionalProductInCVE.VendorName && p.ProductVersions.HasElements());
                    if ((additionalProduct?.ProductVersions.HasElements()).GetValueOrDefault())
                    {
                        Parallel.ForEach(additionalProduct.ProductVersions, parallelOptions, additionalProductVersion =>
                        {
                            productFoundResults.Add(ProcessAdditionalProductVersion(matchedCVEs, cveWithAdditionalProduct, additionalProductInCVE, additionalProductVersion));
                        });
                    }

                    if (productFoundResults.Any(r => r == true))
                    {
                        cancellationTokenSource.Cancel();
                    }
                });
            }
        }

        private bool ProcessAdditionalProductVersion(ConcurrentBag<CVEData> matchedCVEs, CVEData cveWithAdditionalProduct, CVEProductData additionalProductInCVE, ProductVersionData additionalProductVersion)
        {
            CVEMatchType? matchType = null;
            if (additionalProductInCVE.SpecificVersion == additionalProductVersion.Version)
            {
                matchType = CVEMatchType.SpecificVersion;
            }
            else if ((this.ReportSettings.AllVersionsIndicators?.Contains(additionalProductInCVE.SpecificVersion)).GetValueOrDefault())
            {
                matchType = CVEMatchType.WithoutVersion;
            }
            else if ((String.IsNullOrWhiteSpace(additionalProductInCVE.VersionRangeStart) || !additionalProductInCVE.VersionRangeStart.IsAllDigit(this.ReportSettings.StandartVersionSeperator)) &&
                     (String.IsNullOrWhiteSpace(additionalProductInCVE.VersionRangeEnd) || !additionalProductInCVE.VersionRangeEnd.IsAllDigit(this.ReportSettings.StandartVersionSeperator)))
            {
                matchType = CVEMatchType.NonNumericVersionRange;
            }
            else if (VersionHelpers.DoesVersionMatchRange(additionalProductVersion.Version, additionalProductInCVE.VersionRangeStart, additionalProductInCVE.VersionRangeEnd, additionalProductInCVE.IsStartingVersionInclusive, additionalProductInCVE.IsEndingVersionInclusive, this.ReportSettings.StandartVersionSeperator, this.ReportSettings.StandartVersionNumber))
            {
                matchType = CVEMatchType.NumericVersionRange;
            }
            else if ((this.ReportSettings.AllVersionsIndicators?.Contains(additionalProductVersion.Version)).GetValueOrDefault())
            {
                matchType = CVEMatchType.ProductWithoutVersion;
            }

            if (matchType != null)
            {
                CVEData matchedCVEData = cveWithAdditionalProduct.DeepCopy();
                matchedCVEData.MatchType = matchType;

                matchedCVEs.Add(cveWithAdditionalProduct);
                return true;
            }

            return false;
        }
    }
}
